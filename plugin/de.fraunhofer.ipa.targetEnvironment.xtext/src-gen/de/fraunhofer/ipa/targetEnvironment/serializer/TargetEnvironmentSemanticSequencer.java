/*
 * generated by Xtext 2.30.0
 */
package de.fraunhofer.ipa.targetEnvironment.serializer;

import com.google.inject.Inject;
import de.fraunhofer.ipa.targetEnvironment.services.TargetEnvironmentGrammarAccess;
import device.AttributeKind;
import device.CapabilityProperty;
import device.DevicePackage;
import device.DeviceType;
import device.DirectConnection;
import device.IndirectConnection;
import device.MaximumKind;
import device.MinimumKind;
import device.Property;
import device.SelectionKind;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import targetEnvironment.ConfigConnection;
import targetEnvironment.ConnectedDevice;
import targetEnvironment.DeviceInstance;
import targetEnvironment.TargetEnviroment;
import targetEnvironment.TargetEnvironmentPackage;

@SuppressWarnings("all")
public class TargetEnvironmentSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TargetEnvironmentGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DevicePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DevicePackage.ATTRIBUTE_KIND:
				sequence_AttributeKind(context, (AttributeKind) semanticObject); 
				return; 
			case DevicePackage.CAPABILITY_PROPERTY:
				sequence_CapabilityProperty(context, (CapabilityProperty) semanticObject); 
				return; 
			case DevicePackage.DEVICE_TYPE:
				sequence_DeviceType(context, (DeviceType) semanticObject); 
				return; 
			case DevicePackage.DIRECT_CONNECTION:
				sequence_DirectConnection(context, (DirectConnection) semanticObject); 
				return; 
			case DevicePackage.INDIRECT_CONNECTION:
				sequence_IndirectConnection(context, (IndirectConnection) semanticObject); 
				return; 
			case DevicePackage.MAXIMUM_KIND:
				sequence_MaximumKind(context, (MaximumKind) semanticObject); 
				return; 
			case DevicePackage.MINIMUM_KIND:
				sequence_MinimumKind(context, (MinimumKind) semanticObject); 
				return; 
			case DevicePackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case DevicePackage.SELECTION_KIND:
				sequence_SelectionKind(context, (SelectionKind) semanticObject); 
				return; 
			}
		else if (epackage == TargetEnvironmentPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case TargetEnvironmentPackage.CONFIG_CONNECTION:
				sequence_ConfigConnection(context, (ConfigConnection) semanticObject); 
				return; 
			case TargetEnvironmentPackage.CONNECTED_DEVICE:
				sequence_ConnectedDevice(context, (ConnectedDevice) semanticObject); 
				return; 
			case TargetEnvironmentPackage.DEVICE_INSTANCE:
				sequence_DeviceInstance(context, (DeviceInstance) semanticObject); 
				return; 
			case TargetEnvironmentPackage.TARGET_ENVIROMENT:
				sequence_TargetEnviroment(context, (TargetEnviroment) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     CapabilityKind returns AttributeKind
	 *     AttributeKind returns AttributeKind
	 *
	 * Constraint:
	 *     {AttributeKind}
	 * </pre>
	 */
	protected void sequence_AttributeKind(ISerializationContext context, AttributeKind semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CapabilityProperty returns CapabilityProperty
	 *
	 * Constraint:
	 *     (name=EString (value+=EString value+=EString*)? kind=CapabilityKind)
	 * </pre>
	 */
	protected void sequence_CapabilityProperty(ISerializationContext context, CapabilityProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConfigConnection returns ConfigConnection
	 *
	 * Constraint:
	 *     (name=EString connectDevice+=ConnectedDevice connectDevice+=ConnectedDevice*)
	 * </pre>
	 */
	protected void sequence_ConfigConnection(ISerializationContext context, ConfigConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     ConnectedDevice returns ConnectedDevice
	 *
	 * Constraint:
	 *     (refDevice=[DeviceInstance|EString] refConnection=[Connection|EString] (properties+=Property properties+=Property*)?)
	 * </pre>
	 */
	protected void sequence_ConnectedDevice(ISerializationContext context, ConnectedDevice semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeviceInstance returns DeviceInstance
	 *
	 * Constraint:
	 *     (name=EString refDeviceType=[DeviceType|EString])
	 * </pre>
	 */
	protected void sequence_DeviceInstance(ISerializationContext context, DeviceInstance semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, TargetEnvironmentPackage.Literals.DEVICE_INSTANCE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TargetEnvironmentPackage.Literals.DEVICE_INSTANCE__NAME));
			if (transientValues.isValueTransient(semanticObject, TargetEnvironmentPackage.Literals.DEVICE_INSTANCE__REF_DEVICE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, TargetEnvironmentPackage.Literals.DEVICE_INSTANCE__REF_DEVICE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeviceInstanceAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDeviceInstanceAccess().getRefDeviceTypeDeviceTypeEStringParserRuleCall_4_0_1(), semanticObject.eGet(TargetEnvironmentPackage.Literals.DEVICE_INSTANCE__REF_DEVICE_TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     DeviceType returns DeviceType
	 *
	 * Constraint:
	 *     (name=EString (capabilities+=CapabilityProperty capabilities+=CapabilityProperty*)? (connection+=Connection connection+=Connection*)?)
	 * </pre>
	 */
	protected void sequence_DeviceType(ISerializationContext context, DeviceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connection returns DirectConnection
	 *     DirectConnection returns DirectConnection
	 *
	 * Constraint:
	 *     (name=EString (properties+=Property properties+=Property*)?)
	 * </pre>
	 */
	protected void sequence_DirectConnection(ISerializationContext context, DirectConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Connection returns IndirectConnection
	 *     IndirectConnection returns IndirectConnection
	 *
	 * Constraint:
	 *     (name=EString (properties+=Property properties+=Property*)?)
	 * </pre>
	 */
	protected void sequence_IndirectConnection(ISerializationContext context, IndirectConnection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CapabilityKind returns MaximumKind
	 *     MaximumKind returns MaximumKind
	 *
	 * Constraint:
	 *     {MaximumKind}
	 * </pre>
	 */
	protected void sequence_MaximumKind(ISerializationContext context, MaximumKind semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CapabilityKind returns MinimumKind
	 *     MinimumKind returns MinimumKind
	 *
	 * Constraint:
	 *     {MinimumKind}
	 * </pre>
	 */
	protected void sequence_MinimumKind(ISerializationContext context, MinimumKind semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (name=EString value=EString?)
	 * </pre>
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     CapabilityKind returns SelectionKind
	 *     SelectionKind returns SelectionKind
	 *
	 * Constraint:
	 *     {SelectionKind}
	 * </pre>
	 */
	protected void sequence_SelectionKind(ISerializationContext context, SelectionKind semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     TargetEnviroment returns TargetEnviroment
	 *
	 * Constraint:
	 *     (
	 *         name=EString 
	 *         (includeDevice+=DeviceInstance includeDevice+=DeviceInstance*)? 
	 *         (configConnection+=ConfigConnection configConnection+=ConfigConnection*)?
	 *     )
	 * </pre>
	 */
	protected void sequence_TargetEnviroment(ISerializationContext context, TargetEnviroment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
