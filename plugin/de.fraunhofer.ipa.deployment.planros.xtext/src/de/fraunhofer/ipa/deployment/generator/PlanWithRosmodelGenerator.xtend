/*
 * generated by Xtext 2.30.0
 */
package de.fraunhofer.ipa.deployment.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import deploymentPlan.AbstractDeploymentPlan
import de.fraunhofer.ipa.deployment.generator.PlanGenerator
import javax.inject.Inject
import deploymentPlan.AbstractComputationAssignment
import java.util.List
import deployPlanWithRosModel.RossystemImplementationAssignment
import deployPlanWithRosModel.ConfigRosSoftwareComponent
import java.util.stream.Collectors
import deployPlanWithRosModel.DeploymentPlanWithRosModel

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class PlanWithRosmodelGenerator extends AbstractGenerator {

    @Inject
    extension PlanGenerator planGen

    @Inject
    extension DeploymentHelper

    @Inject
    extension DockerComposeCompilerPlanWithRosmodel

    @Inject
    extension RepoInstallCompilerWithRosmodel

  var NamingHelperWithRosmodel extendedNamingHelper = new NamingHelperWithRosmodel


  override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    val plans = resource.allContents.toIterable.filter(AbstractDeploymentPlan)

    generateFiles(plans.toList, fsa)
  }

    def generateFiles(List<AbstractDeploymentPlan> plans, IFileSystemAccess2 fsa){
      for(plan: plans){
        System.out.printf("plan: %s\n", plan.toString)
        extendedNamingHelper.origionNamingHelper.relativePlanFolderPath = plan.name
        extendedNamingHelper.assignmentRossystemRepoInfoMap = plan
        planGen.generateWorkflow(plan, fsa, extendedNamingHelper.origionNamingHelper)
        planGen.generateAnsible(plan, fsa, extendedNamingHelper.origionNamingHelper)
        var assignments = plan.realize.realizations
        for (assignment : assignments){
          System.out.printf("assignment: %s\n", assignment.name)
           planGen.generateDockerFile(assignment, plan, fsa, extendedNamingHelper.origionNamingHelper)
           generateRosInstall(assignment, plan, fsa, extendedNamingHelper)
        }
        generateDockerComposeFile(assignments, fsa, extendedNamingHelper.origionNamingHelper)
        planGen.generateDocuments(plan, fsa)

      }
    }

  def generateDockerComposeFile(List<AbstractComputationAssignment> assignments, IFileSystemAccess2 fsa, NamingHelper namingHelper) {
    var assPerExecutors = collectAssignmentPerExecutor(assignments)
      assPerExecutors.forEach[compDev, assignmentList|
          fsa.generateFile(
          namingHelper.getCyclonConfigPath(compDev.name),
          cycloneDDSConfig)
      fsa.generateFile(
              namingHelper.getDockerComposePath(compDev.name),
          assignmentList.dockerComposeCompiler(compDev))]
  }

  def generateRosInstall(AbstractComputationAssignment assignment, AbstractDeploymentPlan plan, IFileSystemAccess2 fsa, NamingHelperWithRosmodel namingHelper) {
    if(assignment instanceof RossystemImplementationAssignment){
        System.out.println("generateRosInstall")

        var scs = assignment.softwareComponents
        var systems = scs.map[it as ConfigRosSoftwareComponent].stream.map[component].collect(Collectors.toList())
        fsa.generateFile(
                namingHelper.origionNamingHelper.getReposFile(assignment.name, assignment.executedBy.name),
            assignment.RepoInstallCompiler(namingHelper)
        )
      }
    }

}
